# Danger of a Single Story

Furiously typing away at their keyboard, the hackers exclaim, "We're in!". Lights dim, the music swells, and a cutesy animation explains to the theatregoers that the hacking was successful. The reality of programming is far more exciting, if less flashy. Recently, I was working on my 3d render engine, a project I've been working on for quite some time, and stumbled across an incredibly complicated error, that I just couldn't figure out. 

I was in the process of implementing serialization -- essentially, the ability to save and reload scenes from files, and was specifically working on how I could make this work for meshes. I'd written this project in Rust, a language which _forces_ you to be "technically-correct" as possible at compile time, something that's often quite restrictive. This situation was particularly awkward, because there were several different constraints. I had to figure out what "owned" the mesh, i.e. who would be responsible for getting rid of it. I had to figure out when I could apply some computation to the mesh, because there's a significant pre-processing step, called building a BVH, which simply isn't present. I had to figure out how I could still keep the mesh serializable, without breaking any of scene files. And I had to do this all in a sufficiently general way, cause I didn't want my code to end up messy.

It's really these sorts of concerns that dominate when you're programming. So, having spent some time contemplating the problem, I set about researching. After several hours of completely fruitless searching, I finally found a remotely similar problem on the rust-lang forums from 4 years ago. At first, it seemed promising, I could simply create a trait that would allow me to convert it. Sounds simple enough. If only it was actually that simple. Soon after implementing it, I quickly realized that it wouldn't work. Back to the drawing board. 

I went to sleep, and I spent some time, slowly trying to architect a solution. Maybe I could create an interface to "build_bvh", and then, for things that implement the `Aggregate` trait, maybe I could write some code that called `build_bvh` from the conversion from a `Scene` to `ScreneInternal`

So, ready with a new design planned, I sat down to implement it again. This time, I got quite a bit farther, and things seemed to be working. It took a whole week before I realized why this wasn't going to work. I hadn'tanswered the "ownership" question! Back to the drawing board. 

The next one took me all of 3 months, this was near the beginning of October. I'd almost given up, decided that I'd have to tear it all up and restart. And then, over winter break, it hit me. It was an _incredibly_ simple solution, I literally just had to implement `Aggregate` for `Arc<Mesh>`. I'd forgotten one of the most basic principles of how to approach a project.First, make it work. Then, make it right. Finally, make it fast. I'd gotten so preoccupied with making it fast, that I'd wrote off using an `Arc` at all! It was a 3 letter change, but it just worked. It wasn't a perfect solution, but after 3 months of being completely out of ideas, it was an amazing feeling.

I tell this story not to invoke pity, or to describe how hard programming is, but to give a view into what programming actually is. It's hours of meticulous design, of problem solving. It's not flashy, or exciting, but it's extraordinarily intellectually stimulating, it's incredibly satisfying.
